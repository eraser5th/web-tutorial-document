# ユニオン型(Union type)

上記と同じようにして、我々はふと思います。「型が集合なのであれば、集合の和と同じように、型の和も表現可能なのでは？」と。

はい、可能です。

以下のようにして使います。

```typescript
let a: number | string = 1
a = "hoge" // OK!!!!!!
```

aの型は、全ての数値を含む集合numberと、全ての文字列を含む集合stringの和集合なので、いかなる数値および文字列も代入が可能となります。

但し、aはnumberもしくはstringなので、どちらか一方として扱うことはできません。つまり以下のようなコードはコンパイルエラーとなります。

```typescript
let a: number | string = 1
a + 1      // ERROR!
a + "hoge" // ERROR!
```

ではどのようにしてaを扱うのでしょう？その話については、別の章にて扱いたいと思います。

そんなことよりも！これとリテラル型を組み合わせたら凄いことになると思いませんか！

リテラル型では、ある特定の１つの値のみを要素とする型しか宣言できませんでしたが、Unionと組み合わせれば複数の値を要素とする型を宣言できます。

$$
\{1\} \cup \{2\} = \{1, 2\}
$$

```typescript
let a: 1 | 2 = 1
```

これを使うと、例えば特定の文字列指定できるので、使用時のタイプミスを防いだり出ます。

果物の名前として`'apple'`, `'orange'`, `'melon'`のみを扱うとします。ここで「果物の名前の型」をstring型としておくと、人間は愚かなのでここに`'ばななぁ'`を代入しようとします。しかし、型を`string`ではなく`'apple' | 'orange' | 'melon'`としておけば、例え愚かな人間が`'ばななぁ'`としてもコンパイル時にエラーに気づくことができるのです！

```typescript
let a: 'start' | 'center' | 'end' = "ばななぁ" // ERROR!
```

やったね！

まぁ`ばななぁ`は言い過ぎとしても`appple`みたいなスペルミスなどを防いだりできます（型を記述する時点でスペルミスすることはあれど）。

